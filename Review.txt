1) Readme is not for API documentation. It is used the guide for how to run the project, dependencies of the project and contribution guidelines. 
The ideal place to write api docs is either in the OpenAPI file / RAML / Swagger. 
If README is used for the API docs then proper convention should be followed for highlighting difference between normal text and API docs and API response and 
API requests should be more prompt 

References: 
https://docs.readme.com/docs/best-practices
https://swagger.io/
https://www.openapis.org/
https://raml.org/

2) A reviewer cant go ahead without having test casses. Please unit and integration test for your functions and API's. Try to add all casses (Success, Failure and corner casses)
Reference
https://testpyramid.com/ 
https://engineering.atspotify.com/2018/01/11/testing-of-microservices/ 
https://www.baeldung.com/spring-boot-testing

Controllers:
3) Please use REST naming conventions for creating REST API's. URL should be refer as Noun instead of verbs e.g `/addWine` API  should be anme `/wines` with POST method.
- Rethink of API design , think if you need an api for processing order , or not .
https://restfulapi.net/resource-naming/ (Highly Recomended)  

4)If I want to get specific wine than end point should be /wine/{wine_id} where wine_id is the path parameter and Http.Method will be GET. The API /wine{wine_id} 
should return Http.StatusCode 404 if the wine with given ID is not found. Likewise  inorder to get all the wines , I wil have endpoint  /wine  
with HttpMethod.GET and it will return me list of wines , and will return empty list if wines not found.
https://opensource.zalando.com/restful-api-guidelines/ (Highly Recomended)

5) Conversion from DTO to Domain and Domain Object to DTO Should be done on Controller level instead on service level E.g    
 WineDTO wineDTO = WineMapper.INSTANCE.WineToDto(wine) used in Serive for few APIs.Domain should not know implementation details , 
 and likewise domain should not be leaking outside the domain layer therefore controller is the right layer for bidirectional conversions , 
 because controller is information expert here . if we put the responsblity of conversion in service layer then we are leaking external constrains to the domain 

6) getWineByCountry is returning a domain object `Wine` where as getWineByYear is returning a domain object `WineDTO`. 
Domain should not be expose to outside. each API should return DTO instead of domain object.

7) No need to add Getters and setters if you have lombok dependency just add @Data e.g Wine class.

Services
8) Scope of transaction should be on Method level instead of class. E.g you have used @Transactional in Wine class which is not good practice in distributed systems. 
Some of our method may not require database connection but @Transaction on Class level will automatically add Transaction and open database connection on that method.
 This will cause performance issues if our system will scale.

9) 	In class WineImpl method addWine is doing validation on service level. 
It should be part of controller because your service should contaon only domain validation while object is null or not is for API validation.

10) You dont need CommonUtils class. to check either object is empty or not simply use Objects.isNull(wine). CommonUtils.isNullOrEmpty(wine) is doing un neccessary casting of 
objects to string and list. Casting is having operation and CommonUtils.isNullOrEmpty(wine) has too many level of if then else.
 Exeception on valdation should be throw from Controller because it is the part of api validation.
Reference: 	https://www.infoworld.com/article/2076555/java-performance-programming--part-2--the-cost-of-casting.html

11)	The validation for required values should not be the part of domain layer , rather it should be part of api layer . 
In this case the exception Wine details not completed is not required here. 

Also wine.getCountry().isEmpty() could be used for checking if its empty rather then wine.getCountry() != ""  , also  
wine.getCountry() != null is not required , as String is primitive type and by default its empty string 


12) Use contructor based dependency injection instead of property based in sprng 
Reference: https://reflectoring.io/constructor-injection/

13) same as point 10 you dont need CommonUtils.isNullOrEmpty(wine).

14) In class ShoppingCartItemImpl Customer not found exception should not be raised from addWinItems because , the responsibility of this method is to add wine

15) Another approach can be , Instead of checking CommonUtils.isNullOrEmpty(customer), you can check either customerId is empty or not and if its not empty you can call 
customer repository with method findById to check is customer actually exist or invalid id is given.


Repositories

16) Interface methods are bu default public so you can remove public keywords from repository methods e.g in WineRepository 


17) You dont need named queries if you are using Spring data jpa repositories. it automatically cast repository methods to query. e.g remove NamedQueries from `wine` class. 
Data methods are already defined in WineRepository
reference: https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html heading: Example 1.4. Query creation from method names


Exceptions:
18) if  @ExceptionHandler(value = ResourceNotFoundException.class) is defined for every known exception  than method with @ExceptionHandler(value = Exception.class) 
doese not need to check instance of exception for known excpetion because only exceptions @ExceptionHandler(value = )  which are not handle by any method will pass thorught 
 @ExceptionHandler(value = Exception.class)  method.
